Todas las interacciones con el usuario, operaciones de red, eventos del navegador, ... son as铆ncronas. Esto quiere decir que tienen que*esperar*(a que ocurra un evento, a que recibamos una respuesta por http, ...) para poder completar su trabajo.

JavaScript permite manejar*asincron铆a*de una manera elegante gracias a su implementaci贸n de funciones y su naturaleza**_non-blocking_**(que no bloquea el hilo - thread - mientras espera a que se complete una tarea as铆ncrona). En esta unidad veremos**callbacks**,**eventos**y**promesas**como maneras de trabajar con tareas as铆ncronas.

Preguntas como gu铆a para orientar tus esfuerzos de aprendizaje.:

<aside>
 **驴Qu茅 es una tarea as铆ncrona?**
Es una tarea que se ejecuta de manera independiente y no bloquea el flujo principal de un programa. En lugar de esperar a que una tarea se complete antes de continuar con la siguiente, esta permite que m煤ltiples tareas se ejecuten simult谩neamente o en paralelo, lo que mejora la eficiencia y la capacidad de respuesta de una aplicaci贸n.

</aside>

1. **驴Qu茅 significa bloquear el hilo o thread?**
   Significa detener su ejecuci贸n, generalmente debido a una espera o bloqueo de una tarea. Esto puede hacer que una aplicaci贸n parezca congelada si no se gestiona correctamente.

<aside>
 **驴Qu茅 es un callback?**
Es una funci贸n que se pasa como argumento a otra funci贸n y se ejecuta despu茅s de que de que la funci贸n principal haya terminado. facilita la gesti贸n de tareas as铆ncronas o la respuesta a eventos.

</aside>

1. **驴Qu茅 es un evento?**
   Es una acci贸n o suceso que ocurre en un programa, como un clic del rat贸n o una tecla presionada. Los eventos pueden desencadenar respuestas o ejecutar funciones espec铆ficas.
2. **驴C贸mo escuchar eventos?**
   En JavaScript usando el m茅todo `addEventListener` en un elemento HTML o en un objeto que emite eventos. Esto permite que tu c贸digo reaccione cuando ocurre un evento espec铆fico.
3. **驴C贸mo dejar de escuchar eventos?**
   Usando el m茅todo `removeEventListener`. Debes proporcionar la misma funci贸n de callback que se us贸 para agregar el evento.

<aside>
 **驴Qu茅 es una promesa?**
Una promesa es un objeto en JavaScript que representa un valor futuro **que puede estar disponible o no**. Se utiliza para gestionar operaciones as铆ncronas y sus resultados, lo que facilita el manejo de tareas as铆ncronas de manera m谩s ordenada.

</aside>

<aside>
 **驴C贸mo usar promesas?**
Para usar promesas, puedes crear una promesa usando `new Promise()`. Luego, puedes encadenar m茅todos como `then` y `catch` para manejar los resultados exitosos o los errores.

</aside>

1.  **驴C贸mo implementar promesas nuevas?**
    Puedes implementar promesas nuevas creando una funci贸n que devuelve una promesa y luego resolviendo o rechazando esa promesa seg煤n el resultado de la operaci贸n as铆ncrona. Por ejemplo:

        ```jsx
        function miPromesa() {
            return new Promise((resolve, reject) => {
                // Realizar una operaci贸n as铆ncrona
                if (operacionExitosa) {
                    resolve(resultado);
                } else {
                    reject(error);
                }
            });
        }

        ```

2.  **驴C贸mo encadenar promesas?**
    Puedes encadenar promesas utilizando el m茅todo `then` para manejar los resultados de una promesa y devolver otra promesa. Esto permite ejecutar tareas en secuencia. Por ejemplo:

        ```jsx
        miPrimeraPromesa()
            .then(resultado => {
                return miSegundaPromesa(resultado);
            })
            .then(nuevoResultado => {
                console.log(nuevoResultado);
            })
            .catch(error => {
                console.error(error);
            });

        ```

        ## CALLBACKS

        En resumen, un callback es una forma de decirle a una funci贸n qu茅 hacer despu茅s de que haya terminado su trabajo principal, lo que permite manejar tareas as铆ncronas o eventos de manera eficiente en programaci贸n.

        ## **Promesas**

        ### new Promise

        Lo primero es la creaci贸n de una promesa a trav茅s del c贸digo`new Promise(...)`, como puedes ver es un objeto que representa a este dato que puede estar inmediatamente, en el futuro o simplemente no estar. Este objeto para ser creado recibe un*callback*, pero no como todos, sino que uno especial que tiene dos par谩metros que veremos a continuaci贸n.

        ### Par谩metro resolve

        El primer par谩metro del*callback*la promesa es una funci贸n especial que llamaremos cuando el trabajo lento que hacemos se termina. Con esto se da por terminada la promesa y **los datos que queramos retornar se ponen como par谩metros de`resolve`.**

        ### Par谩metro reject

        Nuestro trabajo lento puede fallar, es obvio que todo puede fallar (muchas gracias Murphy), por esto tenemos que tener una forma de comunicar que nuestro proceso lento tuvo un error. Las promesas vienen al rescate y nos proveen de**`reject`, una funci贸n que podemos llamar en caso de error y que recibe como par谩metro.**.. si ya lo adivinaron, **un error** de javascript.

        ### then

        `then`es una funci贸n que el usuario de la promesa provee para cuando el proceso lento termin贸 de ejecutarse correctamente. El n煤mero de par谩metros que recibe son variables y dependen del creador (es muy importante la comunicaci贸n entre ustedes programadoras), generalmente retornan un 煤nico par谩metro con los datos resultantes. Si queremos anidar promesas, tal como vimos anteriormente, es importante al final de esta funci贸n retornar otra promesa. Si en cambio queremos retornar un valor para el siguiente paso, lo haremos de la siguiente forma:

        `//... mucho c贸digo antes ...
        return Promise.resolve(aceptado);
        }.then(
        (aceptado) => {
        // Ac谩 podemos usar el dato que retornamos en el then anterior
        }
        );`

        En resumen, el c贸digo que has proporcionado crea una promesa exitosa inmediatamente con un valor `aceptado` y luego encadena un **`.then()`** para manejar ese valor una vez que la promesa se resuelva exitosamente. Dentro de la funci贸n de callback del **`.then()`**, puedes realizar cualquier acci贸n que necesites con el valor `aceptado` .

        ### catch

        `catch`en tanto, es una funci贸n que ser谩 ejecutada en caso de que**en cualquier parte de la cadena de then haya una falla**. Sirve para capturar y gestionar los errores que se producen en una cadena de promesas.

        - Cuando se produce un error en cualquier parte de una cadena de promesas (por ejemplo, en un **`.then()`** anterior), la ejecuci贸n se detiene en ese punto y se pasa al primer bloque **`catch`** que encuentre en esa cadena.
        - El bloque **`catch`** permite especificar c贸mo manejar el error. Puedes proporcionar una funci贸n de callback que se ejecutar谩 cuando se capture el error. Esta funci贸n puede registrar el error, tomar medidas correctivas o notificar al usuario sobre el problema.

        ## Estado de promesas

        Una promesa puede encontrarse en estos estados:

        - **pending**: Estado inicial, ni terminada exitosamente o rechazada.
        - **fulfilled**: operaci贸n exitosa.
        - **rejected**: operaci贸n fallida o rechazada.
        - **settled**: la Promise ha sido exitosa o rechazada, pero no est谩 pendiente.

        <aside>
        

        </aside>

        Preguntas como gu铆a para orientar tus esfuerzos de aprendizaje.:

        **驴Qu茅 es el modo estricto en JavaScript?**
        El modo estricto (strict mode) en JavaScript es una caracter铆stica que te permite escribir un c贸digo m谩s seguro y libre de errores. Habilit谩ndolo, se aplican reglas m谩s estrictas al c贸digo, lo que ayuda a detectar y evitar errores comunes. Puedes habilitar el modo estricto escribiendo `"use strict";` al comienzo de un archivo o de una funci贸n.

        **驴Qu茅 es un Error y tipos de errores?**
        Un Error en JavaScript es una se帽al de que algo ha salido mal durante la ejecuci贸n del c贸digo. Hay varios tipos de errores, pero los principales son:

        - **Errores de sintaxis:** Ocurren cuando el c贸digo no sigue la estructura y reglas del lenguaje.
        - **Errores de tiempo de ejecuci贸n:** Ocurren durante la ejecuci贸n, como dividir por cero o acceder a una variable no definida.
        - **Errores de l贸gica:** No generan un mensaje de error, pero el programa no funciona como se esperaba debido a un problema en el dise帽o o la l贸gica del c贸digo.

        **驴C贸mo usar try...catch para manejar errores?**`try...catch` es una estructura en JavaScript que permite manejar errores. Colocas el c贸digo propenso a errores dentro del bloque `try`, y si ocurre un error, se captura y se maneja en el bloque `catch`. Esto evita que el programa se detenga abruptamente debido a errores.

        ```jsx
        try {
          // C贸digo propenso a errores
        } catch (error) {
          // Manejo del error
        }

        ```

        **驴C贸mo manejar errores en callbacks?**
        Para manejar errores en callbacks, puedes utilizar un patr贸n com煤n que involucra el uso de la variable `error` como primer argumento en la funci贸n de callback. Luego, dentro del callback, verificas si `error` tiene un valor y, en caso afirmativo, manejas el error.

        ```jsx
        function miCallback(error, resultado) {
          if (error) {
            // Manejo del error
          } else {
            // Trabajo con el resultado
          }
        }

        ```

        **驴C贸mo manejar errores en promesas?**
        En promesas, puedes usar el m茅todo `.catch()` al final de la cadena de `.then()` para manejar errores que puedan ocurrir en cualquier punto de la cadena de promesas. Si ocurre un error en cualquiera de los `.then()`, el control se pasa al bloque `.catch()`.

        ```jsx
        miPromesa()
          .then(resultado => {
            // Trabajo con el resultado
          })
          .catch(error => {
            // Manejo del error
          });

        ```

        Esto permite centralizar el manejo de errores para todas las promesas encadenadas en un solo lugar.

        `try...catch` es una estructura en programaci贸n que se utiliza para manejar situaciones inesperadas o errores que pueden ocurrir durante la ejecuci贸n de un programa.

        - **`try`**: Aqu铆 colocas el c贸digo que deseas probar. Son las instrucciones que pueden generar un error.
        - **`catch`**: Si ocurre un error en el bloque `try`, el programa no se detiene. En su lugar, el control se pasa al bloque `catch`. Dentro del bloque `catch`, puedes escribir instrucciones para manejar el error de una manera controlada.
        - **`finally`**: Opcionalmente, puedes usar un bloque `finally` despu茅s de `catch`. Las instrucciones en `finally` se ejecutan sin importar si ocurri贸 un error o no. Esto es 煤til para realizar limpieza o tareas que siempre deben ocurrir, como cerrar archivos o conexiones de bases de datos.

        Aqu铆 tienes un ejemplo:

        ```jsx
        try {
          // Intentamos hacer algo que puede causar un error
          // Si ocurre un error, el control se pasa al bloque catch
        } catch (error) {
          // Manejamos el error de una manera espec铆fica
        } finally {
          // Estas instrucciones se ejecutan siempre, ocurra o no un error
        }

        ```

        En resumen, `try...catch` te permite ejecutar un c贸digo que podr铆a lanzar errores y proporciona un lugar para manejar esos errores de manera controlada, en lugar de que el programa se detenga abruptamente. Luego, el bloque `finally` (si se utiliza) se ejecuta, independientemente de si ocurri贸 un error o no.
